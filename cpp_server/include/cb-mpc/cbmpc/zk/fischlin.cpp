#include "fischlin.h"

#include <cbmpc/crypto/lagrange.h>

namespace coinbase::zk {

void fischlin_prove(const fischlin_params_t& params, std::function<void()> initialize,
                    std::function<void(int index)> response_begin, std::function<uint32_t(int index, int e_tag)> hash,
                    std::function<void(int index, int e_tag)> save, std::function<void(int e_tag)> response_next) {
  int e_max = params.e_max();
  uint32_t b_mask = params.b_mask();
  int rho = params.rho;

  while (true) {
    bool rho_e_tags_found = true;
    // This function maps to the loop that runs zkClaim in the spec and the common hash that is done after that
    initialize();

    for (int i = 0; i < rho; i++) {
      bool e_tag_found = false;

      // This function performs any special initializations. Specifically, this runs the special case of zkResponse for
      // the first iteration. Subsequent zkResponses are handled by the "next" function. For example, for an optimized
      // version of Fischlin for ZK-DL, instead of computing `z_tag = sigma + e . w` inside a dedicated zkResponse
      // function, this function sets the initial z_tag = sigma and in the "next" function, incrementally update it as
      // `z_tag += w` (since e is incremented by one in each iteration).
      response_begin(i);
      for (int e_tag = 0; e_tag < e_max; e_tag++) {
        // This function internally handles the "common hash" value that was generated by the "restart" function
        uint32_t h = hash(i, e_tag) & b_mask;
        if (h != 0) {
          // This function handles zkRespones and prepares for the next iteration.
          if (e_tag + 1 < e_max) response_next(e_tag + 1);
          continue;
        }

        // This function stores the e_i and z_i in the proper location of the array
        save(i, e_tag);
        e_tag_found = true;
        break;
      }

      if (!e_tag_found) {
        rho_e_tags_found = false;
        break;
      }
    }
    if (rho_e_tags_found) break;
  }
}

}  // namespace coinbase::zk
